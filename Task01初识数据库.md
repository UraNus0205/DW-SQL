# Task01:初识数据库

## 1.1数据库系统概述

### 1.1.1 数据库的4个基本概念

#### 1.数据（data)

#### 数据即描述事物的符号。数据的含义称为数据的语义

#### 2.数据库（DataBase，DB）

数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。

概括地讲，数据库系统具有永久存储、有组织和可共享三个基本特点。

#### 3.数据库管理系统（DataBase Management System，DBMS）

数据库管理系统是位于用户与操作系统之间的一层数据管理软件，和操作系统一样是计算机的基础软件。主要功能包括以下几个方面：

1. 数据定义功能：DBMS提供数据定义语言（DDL），用户通过它可以方便地对数据库中的数据对象的组成和结构进行定义。

2. 数据组织、存储和管理

3. 数据操纵功能

   DBMS提供数据操纵语言（DML），用户可以使用它操纵数据，例如增删改查等。

4. 数据库的事务管理和运行管理

   数据库在建立、运用和维护时由DBMS统一管理和控制，以保证事物的正确运行，保证数据的**安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。**

5. 数据库的事务管理和运行管理

   包括数据库初始数据的输入、转换功能，数据库的转储、恢复功能，数据库的备份和性能监视、分析功能等。

#### 4.数据库系统（DBS）

​		数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DBA）组成的存储、管理、处理和维护数据的系统。

> <center>文件系统数据共享性差、冗余度差、系统独立性差，故产生了数据库系统<center/>

### 1.1.2 数据库系统的特点

#### 1.数据结构化

**数据库系统实现整体数据的结构化**，这是数据库的**主要特征之一**，也是数据库系统与文件系统的**本质区别**。

#### 2.数据的共享性高、冗余度低且易扩充

数据共享可以大大减少数据冗余，节约存储空间。数据共享还能避免数据之间的不相容性与不一致性。

#### 3.数据独立性高

**数据独立性**是借助管理数据的一个显著优点，**包括物理独立性和逻辑独立性。**

- **物理独立性**是指用户的应用程序与数据库中数据的物理存储是相互独立的。也就是说，数据在数据库中怎样存储是由DBMS管理的，用户程序无需了解，应用程序要处理的只是数据的逻辑结构，所以数据的物理存储改变时应用程序不用改变。

- **逻辑独立性**是指用户的应用程序与数据库的逻辑结构是相互独立的。也就是说，数据的逻辑结构改变时用户程序也可以不变。

  数据独立性是由DBMS提供的耳机映像功能保证的。

#### 4.数据由数据库管理系统统一管理和控制

DBMS必须提供如下几方面的数据控制功能：

1. 数据的安全性保护：保护数据以防止不合法使用造成数据的泄密和破坏。
2. 数据的完整性检查：数据的完整性即数据的正确性、有效性和相容性。
3. 并发控制
4. 数据库恢复

## 1.2 数据模型

> <center>数据模型是对现实世界数据特征的抽象。

### 1.2.1 两类数据模型

第一类是概念模型，也称信息模型，第二类是逻辑模型和物理模型。

- 概念模型按用户的观点来对数据和信息建模，主要用于数据库设计。
- 逻辑模型是按计算机系统的观点对数据建模，主要用于DBMS的实现。
- 物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，或在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。

为了把现实世界中的具体事务抽象、组织为某一DBMS支持的数据模型，人们常常首先将**现实世界**抽象为**信息世界**，然后将**信息世界**转换为**机器世界**。

### 1.2.2 概念模型

概念模型实际上是现实世界到机器世界的一个中间层次，用于**信息世界**的建模。

#### 1.信息世界中的基本概念

1. 实体：客观存在并可相互区别的事物。例如学生。

2. 属性：实体所具有的某一特性。例如学生实体可以有学号、姓名等属性。

3. 码（超码）：唯一标识实体的属性集。

   $$
   \begin{cases} 
   超码：能够唯一标识一条记录的属性或属性集。\\
   候选码：能够唯一标识一条记录的最小属性集。\\
   主码：某个能够唯一标识一条记录的最小属性集（是从候选码里人为挑选的一条）。\\
   外码：外部码指的是如果一个关系R的属性或者属性组K，并不是这个关系的码，而是另一个关系S的码，则称K是关系R的外部码，简称外码。
   \end{cases}
   $$

4. 实体型：用实体名及其属性名集合来抽象和刻画同类实体。例如：学生（学号，姓名，性别）就是一个实体型。

5. 实体集：同一类型实体的集合。例如全体学生。

6. 联系：实体之间的联系通常是指不同实体集之间的联系。实体之间的联系有一对一、一对多和多对多等多种类型。

7. 元：参与发生联系的实体数目。

8. 域：属性的取值范围。

#### 2.概念模型的一种表示方法：实体联系方法

该方法用E-R图来描述现实世界的概念模型，E-R方法也称为E-R模型。

### 1.2.3 数据模型的组成要素

数据模型通常由**数据结构（静态）、数据操作（动态）和数据的完整性约束条件**三部分组成。

1. 数据结构：描述数据库的组成对象以及对象之间的联系，是所描述的对象类型的集合，是对系统静态特性的描述。
2. 数据操作：指对数据库中各种对象的实例允许执行的操作的集合，例如增删改查，是对系统动态特性的描述。
3. 数据的完整性约束：是一组完整性规则，在关系模型中，任何关系必须满足**实体完整性、参照完整性和用户定义的完整性**三个条件。

#### 1.2.4 常用的数据模型

- 层次模型
- 网状模型
- 关系模型：对关系的描述一般表示为——>关系名（属性1，属性2，...，属性n）。关系的每一个分量必须是一个不可分的数据项，即不能表中有表。
- 面向对象数据模型

> <center>关系模式的优缺点
>    
> </center>
>
> 优点： 1.建立在严格的数学概念的基础上；
>
> ​			2.数据结构简单清晰，用户易懂易用；
>
> ​			3.关系模式的存取路径对用户透明，从而有更高的数据独立性、更好的安全保密性。
>
> 缺点：查询效率低。

## 1.3 数据库系统的结构

### 1.3.1 数据库系统模式的概念

在数据模式中有“型”（学号，姓名，性别）和“值”（11111111，小明，男）的概念。

模式是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及值的描述。模式的一个具体值成为模式的一个实例。

模式是相对稳定的，实例是相对变动的。

### 1.3.2 数据库系统的三级模式结构

数据库系统的三级模式结构是指数据库系统是由外模式、模式和内模式三级构成，如下图所示。

![20190426202007414](C:\Users\Ursnus\Desktop\20190426202007414.png)



#### 1.模式

模式也称**逻辑模式**，是数据库中**全体数据的逻辑结构和特征的描述**，是所有用户的公共数据视图。它是数据库系统模式的中间层，<u>既不涉及数据的物理存储细节和硬件环境，又与具体的应用程序、所使用的应用开发工具及高级程序设计语言无关。</u>

一个数据库只有一个模式。

#### 2.外模式

外模式也称**子模式或用户模式**，它是数据库用户（应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征和描述，是数据库用户的数据视图，<u>是与某一应用有关的数据的逻辑表示。</u>

**外模式通常是模式的子集，一个数据库可以有多个外模式。**由于**它是各个用户的数据视图**，<u>如果不同的用户在应用需求、看待数据的方式、对数据保密的要求等方面存在差异，则其外模式就是不同的。既使对模式中的同一数据，在外模式中的结构、类型、长度、保密机别等都可以不同。</u>另一方面，<u>同一外模式也可以为某一用户的多个应用系统所使用，但一个应用程序只能使用一个外模式。</u>

外模式是保证数据库安全性的一个有力措施。**每个用户只能看见和访问所对应的外模式中的数据，数据库中的其余数据是不可见的。**

#### 3.内模式

内模式也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。例如，记录的存储方式是堆存储还是升降序，还是索引值；数据是否压缩存储，是否加密等等。

### 1.3.3 数据库的二级映像功能与数据独立性

数据库系统的三级模式是数据的三个抽象级别，它把数据的具体组织留给DBMS，使用户能逻辑地、抽象地处理数据，而不必关心数据在计算机中的具体表示方式和存储方式。为了能够在系统内部实现这三个抽象层次的联系和转换，DBMS在这三级模式之间提供了两层映像：外模式/模式映像和模式/内模式映像。

#### 1. 外模式/模式映像

模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。

<u>当模式改变时，由数据管理员对各个外模式/模式映像作相应改变，可以使外模式保持不变</u>。应用程序是依据数据的外模式编写的，从而应用程序不必修改，**保证了数据与程序的逻辑独立性**，简称<u>**数据的逻辑独立性**</u>。

#### 2. 模式/内模式映像

数据库中只有一个模式，也只有一个内模式，所以**模式/内模式映像是惟一的**，<u>它定义了数据全局逻辑结构与存储结构之间的对应关系</u>。<u>当数据库的存储结构改变时，由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变</u>，从而应用程序也不必改变。**保证了数据与程序的物理独立性**，简称**<u>数据的物理独立性</u>**。

数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去。另外，由于数据的存储由DBMS管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改。

## 1.4初始SQL

### 1.4.1 数据库的创建（CREATE DATABASE语句）

语法：

```sql
CREATE DATABASE < 数据库名称 > ;
```

本课程使用的数据库

```sql
CREATE DATABASE shop;
```

### 1.4.2 表的创建（CREATE TABLE语句）

语法：

```mysql
CREATE TABLE < 表名 >
( < 列名 1> < 数据类型 > < 该列所需约束 > ,
  < 列名 2> < 数据类型 > < 该列所需约束 > ,
  < 列名 3> < 数据类型 > < 该列所需约束 > ,
  < 列名 4> < 数据类型 > < 该列所需约束 > ,
  .
  .
  .
  < 该表的约束 1> , < 该表的约束 2> ,……);
```

创建本课程用到的商品表

```sql
CREATE TABLE product
(product_id CHAR(4) NOT NULL,
 product_name VARCHAR(100) NOT NULL,
 product_type VARCHAR(32) NOT NULL,
 sale_price INTEGER ,
 purchase_price INTEGER ,
 regist_date DATE ,
 PRIMARY KEY (product_id));
```

![6e9122758fe5a27ca02f49d9846855e7c210257d](C:\Users\Ursnus\Desktop\6e9122758fe5a27ca02f49d9846855e7c210257d.png)

### 1.4.3 数据类型的指定

数据库创建的表，所有的列都必须指定数据类型，每一列都不能存储与该列数据类型不符的数据。

四种最基本的数据类型

- INTEGER 型

用来指定存储整数的列的数据类型（数字型），不能存储小数。

- CHAR 型

用来存储定长字符串，当列中存储的字符串长度达不到最大长度的时候，使用半角空格进行补足，由于会浪费存储空间，所以一般不使用。

- VARCHAR 型

用来存储可变长度字符串，定长字符串在字符数未达到最大长度时会用半角空格补足，但可变长字符串不同，即使字符数未达到最大长度，也不会用半角空格补足。

- DATE 型

用来指定存储日期（年月日）的列的数据类型（日期型）。

### 1.4.4 约束的设置

约束是除了数据类型之外，对列中存储的数据进行限制或者追加条件的功能。

`NOT NULL`是非空约束，即该列必须输入数据。

`PRIMARY KEY`是主键约束，代表该列是唯一值，可以通过该列取出特定的行的数据。

### 1.4.5 表的删除和更新

- 删除表的语法：

  ```sql
  DROP TABLE < 表名 > ;
  ```

- 删除product表

  ```sql
  DROP TABLE product;
  ```

需要特别注意的是，删除的表是无法恢复的，只能重新插入，请执行删除操作时要特别谨慎。

- 添加列的ALTER TABEL语句

  ```sql
  ALTER TABLE < 表名 > ADD COLUMN < 列的定义 >;
  ```

- 添加一列可以存储100位的可变长字符串的 product_name_pinyin 列

  ```sql
  ALTER TABLE product ADD COLUMN product_name_pinyin VARCHAR(100);
  ```

- 删除列的 ALTER TABLE 语句

  ```sql
  ALTER TABLE < 表名 > DROP COLUMN < 列名 >;
  ```

- 删除 product_name_pinyin 列

  ```sql
  ALTER TABLE product DROP COLUMN product_name_pinyin;
  ```

ALTER TABLE 语句和 DROP TABLE 语句一样，执行之后无法恢复。误添的列可以通过 ALTER TABLE 语句删除，或者将表全部删除之后重新再创建。

- 清空表内容

  ```sql
  TRUNCATE TABLE TABLE_NAME;
  ```

- 数据的更新

基本语法：

```sql
UPDATE <表名>
SET <列名> = <表达式> [, <列名2>=<表达式2>...];  
WHERE <条件>;  -- 可选，非常重要。
ORDER BY 子句;  --可选
LIMIT 子句; --可选
```

**使用 update 时要注意添加 where 条件，否则将会将所有的行按照语句修改**

```sql
-- 修改所有的注册时间
UPDATE product
   SET regist_date = '2009-10-10';  
-- 仅修改部分商品的单价
UPDATE product
   SET sale_price = sale_price * 10
 WHERE product_type = '厨房用具';  
```

使用 UPDATE 也可以将列更新为 NULL（该更新俗称为NULL清空）。此时只需要将赋值表达式右边的值直接写为 NULL 即可。

```sql
-- 将商品编号为0008的数据（圆珠笔）的登记日期更新为NULL  
UPDATE product
   SET regist_date = NULL
 WHERE product_id = '0008'; 
```

和 INSERT 语句一样， UPDATE 语句也可以将 NULL 作为一个值来使用。
**但是，只有未设置 NOT NULL 约束和主键约束的列才可以清空为NULL。**如果将设置了上述约束的列更新为 NULL，就会出错，这点与INSERT 语句相同。

多列更新

UPDATE 语句的 SET 子句支持同时将多个列作为更新对象。

```sql
-- 基础写法，一条UPDATE语句只更新一列
UPDATE product
   SET sale_price = sale_price * 10
 WHERE product_type = '厨房用具';
UPDATE product
   SET purchase_price = purchase_price / 2
 WHERE product_type = '厨房用具';  
```

该写法可以得到正确结果，但是代码较为繁琐。可以采用合并的方法来简化代码。

```sql
-- 合并后的写法
UPDATE product
   SET sale_price = sale_price * 10,
       purchase_price = purchase_price / 2
 WHERE product_type = '厨房用具'; 
```

### 1.4.6 向product表中插入数据

基本语法：

```sql
INSERT INTO <表名> (列1, 列2, 列3, ……) VALUES (值1, 值2, 值3, ……);  
```

对表进行全列 INSERT 时，可以省略表名后的列清单。这时 VALUES子句的值会默认按照从左到右的顺序赋给每一列。

```sql
-- 包含列清单
INSERT INTO ProductIns (product_id, product_name, product_type, 
sale_price, purchase_price, regist_date) 
VALUES ('0005', '高压锅', 
'厨房用具', 6800, 5000, '2009-01-15');
-- 省略列清单
INSERT INTO ProductIns 
VALUES ('0005', '高压锅', '厨房用具', 6800, 5000, '2009-01-15');  
```

原则上，执行一次 INSERT 语句会插入一行数据。插入多行时，通常需要循环执行相应次数的 INSERT 语句。其实很多 RDBMS 都支持一次插入多行数据。

```sql
-- 通常的INSERT
INSERT INTO ProductIns VALUES ('0002', '打孔器', 
'办公用品', 500, 320, '2009-09-11');
INSERT INTO ProductIns VALUES ('0003', '运动T恤', 
'衣服', 4000, 2800, NULL);
INSERT INTO ProductIns VALUES ('0004', '菜刀', 
'厨房用具', 3000, 2800, '2009-09-20');
-- 多行INSERT （ DB2、SQL、SQL Server、 PostgreSQL 和 MySQL多行插入）
INSERT INTO ProductIns VALUES ('0002', '打孔器', 
'办公用品', 500, 320, '2009-09-11'),
('0003', '运动T恤', '衣服', 4000, 2800, NULL),
('0004', '菜刀', '厨房用具', 3000, 2800, '2009-09-20');  
-- Oracle中的多行INSERT
INSERT ALL INTO ProductIns VALUES ('0002', '打孔器', '办公用品', 500, 320, '2009-09-11')
INTO ProductIns VALUES ('0003', '运动T恤', '衣服', 4000, 2800, NULL)
INTO ProductIns VALUES ('0004', '菜刀', '厨房用具', 3000, 2800, '2009-09-20')
SELECT * FROM DUAL;  
-- DUAL是Oracle特有（安装时的必选项）的一种临时表A。因此“SELECT *FROM DUAL” 部分也只是临时性的，并没有实际意义。  
```

INSERT 语句中想给某一列赋予 NULL 值时，可以直接在 VALUES子句的值清单中写入 NULL。想要插入 NULL 的列一定不能设置 NOT NULL 约束。

```sql
INSERT INTO ProductIns (product_id, product_name, product_type, 
sale_price, purchase_price, regist_date) VALUES ('0006', '叉子', 
'厨房用具', 500, NULL, '2009-09-20');  
```

还可以向表中插入默认值（初始值）。可以通过在创建表的CREATE TABLE 语句中设置DEFAULT约束来设定默认值。

```sql
CREATE TABLE ProductIns
(product_id CHAR(4) NOT NULL,
（略）
sale_price INTEGER
（略）	DEFAULT 0, -- 销售单价的默认值设定为0;
PRIMARY KEY (product_id));  
```

可以使用INSERT … SELECT 语句从其他表复制数据。

```sql
-- 将商品表中的数据复制到商品复制表中
INSERT INTO ProductCopy (product_id, product_name, product_type, sale_price, purchase_price, regist_date)
SELECT product_id, product_name, product_type, sale_price, 
purchase_price, regist_date
FROM Product;  
```



- 本课程用表插入数据sql如下：

```sql
- DML ：插入数据
STARTTRANSACTION;
INSERT INTO product VALUES('0001', 'T恤衫', '衣服', 1000, 500, '2009-09-20');
INSERT INTO product VALUES('0002', '打孔器', '办公用品', 500, 320, '2009-09-11');
INSERT INTO product VALUES('0003', '运动T恤', '衣服', 4000, 2800, NULL);
INSERT INTO product VALUES('0004', '菜刀', '厨房用具', 3000, 2800, '2009-09-20');
INSERT INTO product VALUES('0005', '高压锅', '厨房用具', 6800, 5000, '2009-01-15');
INSERT INTO product VALUES('0006', '叉子', '厨房用具', 500, NULL, '2009-09-20');
INSERT INTO product VALUES('0007', '擦菜板', '厨房用具', 880, 790, '2008-04-28');
INSERT INTO product VALUES('0008', '圆珠笔', '办公用品', 100, NULL, '2009-11-11');
COMMIT;
```

